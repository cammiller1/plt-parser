(* Code generation: translate takes a semantically checked AST and
produces LLVM IR

*)

module L = Llvm
module A = Ast
open Sast

module StringMap = Map.Make(String)

(* translate : Sast.program -> Llvm.module *)
(* context = the thing we need to pass to certain LLVM functions 
internally: some C++ class 
REMINDER: L.pointer_type i8_t IS A CHAR POINTER. WILL NEED FOR STRINGS
*)
let translate (statements) =
  let context    = L.global_context () in

  (* Create the LLVM compilation module into which
     we will generate code *)
  let the_module = L.create_module context "jpie" in


  (* Get types from the context *)
  (* llvm only supports primitive types *)
  let i32_t      = L.i32_type       context  (* 32-bit int type *)
  and i8_t       = L.i8_type        context  (* caracters *)
  and i1_t       = L.i1_type        context  (* boolean type *)
  and float_t    = L.double_type    context  (* double/float type *)
  (* and void_t     = L.void_type      context   void type *)
  (* and string_t   = L.pointer_type   i8_t      pointer type to char *)
  in

  (* Return the LLVM type for a Jpie type *)
  let ltype_of_typ = function
      A.Int   -> i32_t
    | A.Boolean  -> i1_t
    | A.Float -> float_t
    (* | A.Void  -> void_t *)
    (* | A.String -> string_t *) (* added for our project *)
  in

   (* Create a map of global variables after creating each *)
  let global_vars : L.llvalue StringMap.t =
    let global_var m (t, n) = 
      let init = match t with
          A.Float -> L.const_float (ltype_of_typ t) 0.0
        | _ -> L.const_int (ltype_of_typ t) 0
      in StringMap.add n (L.define_global n init the_module) m in
    (* the below empty list is supposed to be empty list of tuples. if error find this *)
    List.fold_left global_var StringMap.empty [] in


  (* Declaring external functions *)
  (* create a link to the C library's "printf" *)
  let printf_t : L.lltype = 
      (* the [| and |] indicates an Ocaml array*)
      L.var_arg_function_type i32_t [| L.pointer_type i8_t |] in
    (* below LLVM's connection to a built-in function *)
  let printf_func : L.llvalue = 
      L.declare_function "printf" printf_t the_module in

  (** setup main() where all the code will go **)
  let main_ftype = L.function_type i32_t [||] in   (* ftype is the full llvm function signature *)
  let main_function = L.define_function "main" main_ftype the_module in
  let builder = L.builder_at_end context (L.entry_block main_function) in

    let int_format_str = L.build_global_stringptr "%d\n" "fmt" builder
    and float_format_str = L.build_global_stringptr "%g\n" "fmt" builder in


  (* purpose of locals: given a var name, where can we find the value of that var in memory? *)

  (* let lookup n = StringMap.find n global_vars in *)

    
        (* Construct code for an expression; return its value *)
    (* An expression in LLVM always turns into code in a single basic block (not true for stmts) *)
    (* build instructions in the given builder that evaluate the expr; return the expr's value *)
    let rec expr builder ((_, e) : sexpr) = match e with
        SLiti i  -> L.const_int i32_t i
      | SLitb b  -> L.const_int i1_t (if b then 1 else 0)
      | SLitf l -> L.const_float_of_string float_t l
      | SNoexpr     -> L.const_int i32_t 0
      (* | SNoexpr     -> L.const_int i32_t 0 *)
      (*
      | Sid s       -> L.build_load (lookup s) s builder  (* get the value of the variable *)
      | SAssign (t, s, e) -> let e' = expr builder e in  (* s - name of var we want to assign to, e - expr we want to generate code for *)
                          ignore(L.build_store e' (lookup s) builder); e' 
                          in
                          let local_var = L.build_alloca (ltype_of_typ t) n builder
                          in StringMap.add n local_var m 
    *)
      (* a bunch of stuff between here *) 
      
      | SCall ("print", [e]) | SCall ("printb", [e]) ->
          L.build_call printf_func [| int_format_str ; (expr builder e) |]
            "printf" builder
      | SCall ("printf", [e]) -> 
          L.build_call printf_func [| float_format_str ; (expr builder e) |]
          "printf" builder

    in


    (* Build the code for the given statement; return the builder for
       the statement's successor (i.e., the next instruction will be built
       after the one generated by this call) *)
     let rec stmt builder = function
        SExpr e -> ignore(expr builder e); builder 
    in

     (* Return the value for a variable or formal argument.
       Check local names first, then global names *)
    (* EITHER THE FIRST OR SECOND SHOULD ALWAYS WORK. IF NOT THE PROGRAM IS ILL-FORMED AND 
     THE CHECKING SHOULD HAVE CAUGHT THE ISSUE *)
    

    (* Build the code for each statement in the function *)
    let builder = stmt builder (statements) in

    the_module  (* return the LLVM module result *)