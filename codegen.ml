(* Code generation: translate takes a semantically checked AST and
produces LLVM IR

*)

module L = Llvm
module A = Ast
open Sast

module StringMap = Map.Make(String)

(* translate : Sast.program -> Llvm.module *)
(* context = the thing we need to pass to certain LLVM functions 
internally: some C++ class 
REMINDER: L.pointer_type i8_t IS A CHAR POINTER. WILL NEED FOR STRINGS
*)
let translate (statements) =
  let context    = L.global_context () in

  (* Create the LLVM compilation module into which
     we will generate code *)
  let the_module = L.create_module context "pie" in


  (* Get types from the context *)
  (* llvm only supports primitive types *)
  let i32_t      = L.i32_type       context  (* 32-bit int type *)
  and i8_t       = L.i8_type        context  (* caracters *)
  and i1_t       = L.i1_type        context  (* boolean type *)
  and float_t    = L.double_type    context  (* double/float type *)
  (* and void_t     = L.void_type      context   void type *)
  (* and string_t   = L.pointer_type   i8_t      pointer type to char *)
  in

  (* Return the LLVM type for a Jpie type *)
  let ltype_of_typ = function
      A.Int   -> i32_t
    | A.Boolean  -> i1_t
    | A.Float -> float_t
    (* | A.Void  -> void_t *)
    (* | A.String -> string_t *) (* added for our project *)
  in


  (* Declaring external functions *)
  (* create a link to the C library's "printf" *)
  let printf_t : L.lltype = 
      (* the [| and |] indicates an Ocaml array*)
      L.var_arg_function_type i32_t [| L.pointer_type i8_t |] in
    (* below LLVM's connection to a built-in function *)
  let printf_func : L.llvalue = 
      L.declare_function "printf" printf_t the_module in


  (* Create a map of global variables after creating each *)
  let vars : L.llvalue StringMap.t =
    let var m (t, n) = 
      let init = match t with
          A.Float -> L.const_float (ltype_of_typ t) 0.0
        | _ -> L.const_int (ltype_of_typ t) 0
      in StringMap.add n (L.define_global n init the_module) m in
    (* assuming empty list works *)
    List.fold_left global_var StringMap.empty [] in



  (* purpose of locals: given a var name, where can we find the value of that var in memory? *)

  (* let lookup n = StringMap.find n global_vars in *)

    
    (* Build the code for the given statement; return the builder for
       the statement's successor (i.e., the next instruction will be built
       after the one generated by this call) *)
     let rec stmt builder = function
       SExpr e -> ignore(expr builder e); builder 


     in 

     (* Return the value for a variable or formal argument.
       Check local names first, then global names *)
    (* EITHER THE FIRST OR SECOND SHOULD ALWAYS WORK. IF NOT THE PROGRAM IS ILL-FORMED AND 
     THE CHECKING SHOULD HAVE CAUGHT THE ISSUE *)
    
    let lookup n = StringMap.find n vars



    (* Construct code for an expression; return its value *)
    (* An expression in LLVM always turns into code in a single basic block (not true for stmts) *)
    (* build instructions in the given builder that evaluate the expr; return the expr's value *)
    let rec expr builder ((_, e) : sexpr) = match e with
        SLiti i  -> L.const_int i32_t i
      | SLitb b  -> L.const_int i1_t (if b then 1 else 0)
      | SLitf l -> L.const_float_of_string float_t l
      (* | SNoexpr     -> L.const_int i32_t 0 *)
      | Sid s       -> L.build_load (lookup s) s builder  (* get the value of the variable *)
      | SAssign (t, s, e) -> let e' = expr builder e in  (* s - name of var we want to assign to, e - expr we want to generate code for *)
                          ignore(L.build_store e' (lookup s) builder); e' 
                          in
                          let local_var = L.build_alloca (ltype_of_typ t) n builder
                          in StringMap.add n local_var m 

      (* a bunch of stuff between here *) 
      
      | SCall ("print", [e]) | SCall ("printb", [e]) ->
          L.build_call printf_func [| int_format_str ; (expr builder e) |]
            "printf" builder
          L.build_call printf_func [| float_format_str ; (expr builder e) |]
            "printf" builder
      
    in

    (* LLVM insists each basic block end with exactly one "terminator" 
       instruction that transfers control.  This function runs "instr builder"
       if the current block does not already have a terminator.  Used,
       e.g., to handle the "fall off the end of the function" case. *)
    let add_terminal builder instr =
      match L.block_terminator (L.insertion_block builder) with
        Some _ -> ()
      | None -> ignore (instr builder) in

    

     (* *)
     List.iter build_function_body functions;
     the_module  (* return the LLVM module result *)







